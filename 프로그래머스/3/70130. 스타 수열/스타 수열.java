// x의 길이가 2 이상의 짝수
// x의 길이를 2n 이라고 할때, 다음과 같은 n개의 집합의 교집합의 원소의 개수가 1이상
// 길이가 가장 긴 스타수열의 길이를 return

// 스타수열에 있어서 공통되는 값이 무조건 하나이상 있어야 한다.
// 그렇다는것은 cnt에 있어서 최소 2개이상 있어야 하는것
// 그러한 후보 값을 기준으로
// 후보값이 포함된 집합을 찾는데, 자기 자신과 인접한 원소에 대해서 검사하면 된다.

// 위와는 다른 풀이를 생각해보자.
// 애초에 공통원소가 될 교집합 원소는 반드시 cnt가 2회 이상 불리게 되어있다.

// 그리고 어디까지가 집합으로 구성되어있는지 인덱스를 해놓는다면, 다음 집합을 찾을 때에도 중복된 집합을 안만들 수 있다.
// 마킹 해놓는거지. 인덱스 번호로 0번이 올 수 있으므로 -1로 마스킹 해놓는다.
// 그리고 해당 원소가 교집합으로 존재하는 집합의 개수가 몇번 등장했는지 체크한다.

// 마지막의 cnt배열을 순회하면서 최대 쌍을 찾고, 그 쌍의 *2 가 곧 정답이 된다.
// 왜냐하면 그 원소를 기준으로 만든 집합이 2개라는 것이고 집합당 원소는 반드시 2개이므로 스타수열의 길이는 2를 곱해야 된다.

import java.util.*;
class Solution {
    public int solution(int[] a) {
        int answer = 0;
        int size = 0;
        int[] cnt = new int[a.length];
        int[] index = new int[a.length];
        Arrays.fill(index, -1);
        for(int i = 0; i < a.length - 1; i++) {
            // 각각의 숫자를 사용해서 만들 수 있는 최대 쌍의 개수
            // 만약 아래의 조건이 사라지면 틀리게 된다.
            if (a[i] == a[i + 1]) continue;
            // 반례로 [5, 5, 5, 5, 5, 5] 가 있다.
            // 만약 스타수열을 넣을려면 스타 수열 내 원소에서 2n - 2 과 2n - 1은 절대로 같아선 안된다.
            // 하지만 여기서 위 조건이 없다면 아래의 조건들은 단순히 선택된 원소 두 가지의 집합가능성을 보는것이기 때문에
            // 정답이 위의 반례기준으로 6이 나와버린다.
            
            if (index[a[i]] < i) {
                // a[i] 원소를 교집합 원소로 하면서 이전과 겹치지 않으면서 집합을 만들 수 있다면, 카운팅
                cnt[a[i]]++;
                index[a[i]] = i + 1;
            }
            
            if (index[a[i + 1]] < i) {
                // a[i + 1] 원소를 교집합 원소로 하면서 이전과 겹치지 않으면서 집합을 만들 수 있다면, 카운팅
                cnt[a[i + 1]]++;
                
                // 절대로 까먹어선 안된다. 마스킹 해놔야지 나중에 겹치는 원소로 판단 안할 수 있다.
                index[a[i + 1]] = i + 1;
                
            }
        }
        
        for(int i = 0; i < cnt.length; i++) {
            answer = Math.max(answer, cnt[i]);
        }
         
        return answer * 2;
    }
}